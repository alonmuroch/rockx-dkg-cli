// Code generated by fastssz. DO NOT EDIT.
// Hash: 45e79ec7514e3f5924fe176d8388d55f8a71640b4f49660fd1c391f2771f0d15
package node

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Transport object
func (t *Transport) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transport object to a target array
func (t *Transport) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(36)

	// Field (0) 'Type'
	dst = ssz.MarshalUint64(dst, uint64(t.Type))

	// Field (1) 'Identifier'
	dst = append(dst, t.Identifier[:]...)

	// Offset (2) 'Data'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(t.Data)

	// Field (2) 'Data'
	if len(t.Data) > 8388608 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Data...)

	return
}

// UnmarshalSSZ ssz unmarshals the Transport object
func (t *Transport) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 36 {
		return ssz.ErrSize
	}

	tail := buf
	var o2 uint64

	// Field (0) 'Type'
	t.Type = TransportType(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'Identifier'
	copy(t.Identifier[:], buf[8:32])

	// Offset (2) 'Data'
	if o2 = ssz.ReadOffset(buf[32:36]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 < 36 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Data'
	{
		buf = tail[o2:]
		if len(buf) > 8388608 {
			return ssz.ErrBytesLength
		}
		if cap(t.Data) == 0 {
			t.Data = make([]byte, 0, len(buf))
		}
		t.Data = append(t.Data, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transport object
func (t *Transport) SizeSSZ() (size int) {
	size = 36

	// Field (2) 'Data'
	size += len(t.Data)

	return
}

// HashTreeRoot ssz hashes the Transport object
func (t *Transport) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transport object with a hasher
func (t *Transport) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Type'
	hh.PutUint64(uint64(t.Type))

	// Field (1) 'Identifier'
	hh.PutBytes(t.Identifier[:])

	// Field (2) 'Data'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(t.Data))
		if byteLen > 8388608 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(t.Data)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (8388608+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the SignedTransport object
func (s *SignedTransport) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedTransport object to a target array
func (s *SignedTransport) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(16)

	// Offset (0) 'Message'
	dst = ssz.WriteOffset(dst, offset)
	if s.Message == nil {
		s.Message = new(Transport)
	}
	offset += s.Message.SizeSSZ()

	// Field (1) 'Signer'
	dst = ssz.MarshalUint64(dst, s.Signer)

	// Offset (2) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signature)

	// Field (0) 'Message'
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Signature'
	if len(s.Signature) > 2048 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedTransport object
func (s *SignedTransport) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 16 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o2 uint64

	// Offset (0) 'Message'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 16 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Signer'
	s.Signer = ssz.UnmarshallUint64(buf[4:12])

	// Offset (2) 'Signature'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o0 > o2 {
		return ssz.ErrOffset
	}

	// Field (0) 'Message'
	{
		buf = tail[o0:o2]
		if s.Message == nil {
			s.Message = new(Transport)
		}
		if err = s.Message.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (2) 'Signature'
	{
		buf = tail[o2:]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(s.Signature) == 0 {
			s.Signature = make([]byte, 0, len(buf))
		}
		s.Signature = append(s.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedTransport object
func (s *SignedTransport) SizeSSZ() (size int) {
	size = 16

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(Transport)
	}
	size += s.Message.SizeSSZ()

	// Field (2) 'Signature'
	size += len(s.Signature)

	return
}

// HashTreeRoot ssz hashes the SignedTransport object
func (s *SignedTransport) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedTransport object with a hasher
func (s *SignedTransport) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signer'
	hh.PutUint64(s.Signer)

	// Field (2) 'Signature'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.Signature))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(s.Signature)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Init object
func (i *Init) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(i)
}

// MarshalSSZTo ssz marshals the Init object to a target array
func (i *Init) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(20)

	// Offset (0) 'Operators'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(i.Operators) * 8

	// Field (1) 'T'
	dst = ssz.MarshalUint64(dst, i.T)

	// Offset (2) 'WithdrawalCredentials'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(i.WithdrawalCredentials)

	// Field (3) 'Fork'
	dst = append(dst, i.Fork[:]...)

	// Field (0) 'Operators'
	if len(i.Operators) > 13 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(i.Operators); ii++ {
		dst = ssz.MarshalUint64(dst, i.Operators[ii])
	}

	// Field (2) 'WithdrawalCredentials'
	if len(i.WithdrawalCredentials) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, i.WithdrawalCredentials...)

	return
}

// UnmarshalSSZ ssz unmarshals the Init object
func (i *Init) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 20 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o2 uint64

	// Offset (0) 'Operators'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 20 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'T'
	i.T = ssz.UnmarshallUint64(buf[4:12])

	// Offset (2) 'WithdrawalCredentials'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o0 > o2 {
		return ssz.ErrOffset
	}

	// Field (3) 'Fork'
	copy(i.Fork[:], buf[16:20])

	// Field (0) 'Operators'
	{
		buf = tail[o0:o2]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		i.Operators = ssz.ExtendUint64(i.Operators, num)
		for ii := 0; ii < num; ii++ {
			i.Operators[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}

	// Field (2) 'WithdrawalCredentials'
	{
		buf = tail[o2:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(i.WithdrawalCredentials) == 0 {
			i.WithdrawalCredentials = make([]byte, 0, len(buf))
		}
		i.WithdrawalCredentials = append(i.WithdrawalCredentials, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Init object
func (i *Init) SizeSSZ() (size int) {
	size = 20

	// Field (0) 'Operators'
	size += len(i.Operators) * 8

	// Field (2) 'WithdrawalCredentials'
	size += len(i.WithdrawalCredentials)

	return
}

// HashTreeRoot ssz hashes the Init object
func (i *Init) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(i)
}

// HashTreeRootWith ssz hashes the Init object with a hasher
func (i *Init) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Operators'
	{
		if len(i.Operators) > 13 {
			err = ssz.ErrListTooBig
			return
		}
		subIndx := hh.Index()
		for _, i := range i.Operators {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(i.Operators))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (1) 'T'
	hh.PutUint64(i.T)

	// Field (2) 'WithdrawalCredentials'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(i.WithdrawalCredentials))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(i.WithdrawalCredentials)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (3) 'Fork'
	hh.PutBytes(i.Fork[:])

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Output object
func (o *Output) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(o)
}

// MarshalSSZTo ssz marshals the Output object to a target array
func (o *Output) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(152)

	// Offset (0) 'EncryptedShare'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(o.EncryptedShare)

	// Offset (1) 'SharePK'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(o.SharePK)

	// Field (2) 'ValidatorPK'
	if len(o.ValidatorPK) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, o.ValidatorPK...)

	// Field (3) 'DepositDataPartialSignature'
	if len(o.DepositDataPartialSignature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, o.DepositDataPartialSignature...)

	// Field (0) 'EncryptedShare'
	if len(o.EncryptedShare) > 2048 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, o.EncryptedShare...)

	// Field (1) 'SharePK'
	if len(o.SharePK) > 2048 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, o.SharePK...)

	return
}

// UnmarshalSSZ ssz unmarshals the Output object
func (o *Output) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 152 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'EncryptedShare'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 152 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'SharePK'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'ValidatorPK'
	if cap(o.ValidatorPK) == 0 {
		o.ValidatorPK = make([]byte, 0, len(buf[8:56]))
	}
	o.ValidatorPK = append(o.ValidatorPK, buf[8:56]...)

	// Field (3) 'DepositDataPartialSignature'
	if cap(o.DepositDataPartialSignature) == 0 {
		o.DepositDataPartialSignature = make([]byte, 0, len(buf[56:152]))
	}
	o.DepositDataPartialSignature = append(o.DepositDataPartialSignature, buf[56:152]...)

	// Field (0) 'EncryptedShare'
	{
		buf = tail[o0:o1]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(o.EncryptedShare) == 0 {
			o.EncryptedShare = make([]byte, 0, len(buf))
		}
		o.EncryptedShare = append(o.EncryptedShare, buf...)
	}

	// Field (1) 'SharePK'
	{
		buf = tail[o1:]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(o.SharePK) == 0 {
			o.SharePK = make([]byte, 0, len(buf))
		}
		o.SharePK = append(o.SharePK, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Output object
func (o *Output) SizeSSZ() (size int) {
	size = 152

	// Field (0) 'EncryptedShare'
	size += len(o.EncryptedShare)

	// Field (1) 'SharePK'
	size += len(o.SharePK)

	return
}

// HashTreeRoot ssz hashes the Output object
func (o *Output) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(o)
}

// HashTreeRootWith ssz hashes the Output object with a hasher
func (o *Output) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'EncryptedShare'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(o.EncryptedShare))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(o.EncryptedShare)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	// Field (1) 'SharePK'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(o.SharePK))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(o.SharePK)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	// Field (2) 'ValidatorPK'
	if len(o.ValidatorPK) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(o.ValidatorPK)

	// Field (3) 'DepositDataPartialSignature'
	if len(o.DepositDataPartialSignature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(o.DepositDataPartialSignature)

	hh.Merkleize(indx)
	return
}
